<!DOCTYPE html>

<html>

<head>
	<link rel="stylesheet" href="styles.css">
</head>

<body>
	 <h1>Time, Space, Complexity</h1>
	<p>Time and space complexity are fundamental concepts in computer science that measure how an algorithm's efficient scales with the size of its input. They are used to evaluate how much time and memory an algorithm needs to run.It is a fundamental concept in computer science that describes the amount of computational time an algorithm takes relative to the size of its input, denoted as *n*. It provides an asymptotic upper bound on the growth rate of an algorithm's runtime, typically expressed using Big-O notation (e.g., *O(1)*, *O(log n)*, *O(n)*, *O(n²)*). For example, an algorithm with *O(n)*  scales nearly with input size, while an *O(n²)* algorithm grows quadratically. algorithms often strive for logarithmic (*O(log n)*) or linear time, whereas exponential complexities (*O(2ⁿ)*) are generally infeasible for large inputs.It helps optimize performance by comparing  independent of hardware-specific factors.</p>
    <p><b> Space complexity</b> Space complexity measures the amount of memory an algorithm requires relative to its input size (*n*). It determines how much additional storage (beyond the input itself) is needed during execution. Like time complexity, it is expressed using Big-O notation (e.g., *O(1)*, *O(n)*, *O(n²)*).  
    An algorithm with *O(1)*  uses a fixed amount of memory, regardless of input size. For example, a loop summing numbers requires only one variable for storage. In contrast, *O(n)*  means memory usage grows linearly with input size, such as storing an array or a recursive call stack with *n* depth.  
    Higher  like *O(n²)*, occur when algorithms generate 2D structures (e.g., matrices). Recursive algorithms may also have significant  overhead due to stack frames. Optimizing is crucial for memory-constrained systems, often trading time efficiency for reduced storage.  
    Key considerations include: Auxiliary  (extra memory used by the algorithm).  Input storage (whether the input is modified in-place).Trade-offs between time and space (e.g., caching vs. recomputation).  Understanding space complexity ensures efficient memory usage alongside runtime performance.</p>

</body>
</html>
